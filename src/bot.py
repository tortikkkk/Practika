import telebot
from telebot import types
import os
import random

TOKEN = '7618568984:AAGbduDv2pnUGHaT2uxigKYa4gydkkmN1-k'
bot = telebot.TeleBot(TOKEN)

MEMES_FOLDER = 'pictures'
TEXTS_FILE = 'fun.txt'
RESPONSES = [
    "–ö–∞–∫–∞—è —Å–º–µ—à–Ω–∞—è —à—É—Ç–∫–∞!",
    "–ê—Ö–∞—Ö—Ö–∞—Ö–∞—Ö—Ö–∞—Ö–∞—Ö–∞—Ö—Ö–∞—Ö–∞—Ö—Ö–∞!",
    "–•–æ—Ä–æ—à–∞—è —à—É—Ç–∫–∞, –ø–æ—Å–º–µ—è–ª—Å—è!",
    "üòÇüòÇüòÇ",
    "–õ–æ–ª, —ç—Ç–æ –±—ã–ª–æ —Å–º–µ—à–Ω–æ!",
    "–Ø –∑–∞–ø–æ–º–Ω—é —ç—Ç—É —à—É—Ç–∫—É!"
]

disliked_content = {'memes': [], 'texts': []}
user_last_message = {}

def create_main_keyboard():
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    btn1 = types.KeyboardButton('‚ûï –ú–µ–º')
    btn2 = types.KeyboardButton('üìÑ –ê–Ω–µ–∫–¥–æ—Ç')
    markup.add(btn1, btn2)
    return markup

def create_feedback_keyboard():
    markup = types.InlineKeyboardMarkup()
    like = types.InlineKeyboardButton(text='üëç –õ–∞–π–∫', callback_data='like')
    dislike = types.InlineKeyboardButton(text='üëé –î–∏–∑–ª–∞–π–∫', callback_data='dislike')
    markup.add(like, dislike)
    return markup

def offer_services(chat_id):
    bot.send_message(
        chat_id,
        "–ß—Ç–æ —Ö–æ—á–µ—à—å —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?",
        reply_markup=create_main_keyboard()
    )

@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.reply_to(
        message,
        f'–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!\n'
        '‚Ä¢ –ù–∞–∂–º–∏ "‚ûï –ú–µ–º", –∏ —è –ø—Ä–∏—à–ª—é —Ç–µ–±–µ –º–µ–º.\n'
        '‚Ä¢ –ù–∞–∂–º–∏ "üìÑ –ê–Ω–µ–∫–¥–æ—Ç", —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–ª—É—á–∞–π–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n'
        '‚Ä¢ –ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ –º–Ω–µ —á—Ç–æ-–Ω–∏–±—É–¥—å —Å–º–µ—à–Ω–æ–µ!',
        reply_markup=create_main_keyboard()
    )

@bot.message_handler(func=lambda message: message.text == '‚ûï –ú–µ–º')
def send_meme(message):
    if not os.path.exists(MEMES_FOLDER):
        bot.send_message(message.chat.id, '–ü–∞–ø–∫–∞ —Å –º–µ–º–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!')
        offer_services(message.chat.id)
        return

    available_memes = [
        f for f in os.listdir(MEMES_FOLDER) 
        if f.endswith(('.jpg', '.jpeg', '.png')) 
        and f not in disliked_content['memes']
    ]
    
    if not available_memes:
        bot.send_message(message.chat.id, '–í –ø–∞–ø–∫–µ –Ω–µ—Ç –Ω–æ–≤—ã—Ö –º–µ–º–æ–≤ –¥–ª—è —Ç–µ–±—è –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏! –ü–æ–ø—Ä–æ–±—É–π –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞.')
        offer_services(message.chat.id)
        return
    
    random_meme = random.choice(available_memes)
    meme_path = os.path.join(MEMES_FOLDER, random_meme)
    
    with open(meme_path, 'rb') as photo:
        msg = bot.send_photo(
            message.chat.id, 
            photo, 
            reply_markup=create_feedback_keyboard()
        )
        user_last_message[message.chat.id] = {
            'type': 'meme', 
            'content': random_meme, 
            'message_id': msg.message_id
        }

@bot.message_handler(func=lambda message: message.text == 'üìÑ –ê–Ω–µ–∫–¥–æ—Ç')
def send_random_text(message):
    try:
        with open(TEXTS_FILE, 'r', encoding='utf-8') as f:
            all_texts = [line.strip() for line in f.readlines() if line.strip()]

        available_texts = [text for text in all_texts if text not in disliked_content['texts']]
        
        if not available_texts:
            bot.reply_to(message, "–î–ª—è —Ç–µ–±—è –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –Ω–æ–≤—ã–µ –∞–Ω–µ–∫–¥–æ—Ç—ã –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏! –ü–æ–ø—Ä–æ–±—É–π –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞.")
            offer_services(message.chat.id)
            return
        
        random_text = random.choice(available_texts)
        msg = bot.reply_to(
            message, 
            random_text, 
            reply_markup=create_feedback_keyboard()
        )
        user_last_message[message.chat.id] = {
            'type': 'text', 
            'content': random_text, 
            'message_id': msg.message_id
        }
    except Exception as e:
        bot.reply_to(message, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
        offer_services(message.chat.id)

@bot.callback_query_handler(func=lambda call: True)
def handle_feedback(call):
    chat_id = call.message.chat.id
    user_data = user_last_message.get(chat_id, {})
    
    if call.data == 'like':
        bot.send_message(chat_id, "–Ø —Ä–∞–¥–∞ —á—Ç–æ —Ç–µ–±–µ –ø–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å! üòä")
    elif call.data == 'dislike':
        if user_data['type'] == 'meme':
            disliked_content['memes'].append(user_data['content'])
        elif user_data['type'] == 'text':
            disliked_content['texts'].append(user_data['content'])
        
        bot.send_message(chat_id, "–ì—Ä—É—Å—Ç–Ω–æ —á—Ç–æ —Ç–µ–±–µ –Ω–µ –ø–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å. –Ø –±–æ–ª—å—à–µ –Ω–µ –±—É–¥—É –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —ç—Ç–æ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç. üòî")
    
    try:
        bot.edit_message_reply_markup(
            chat_id=chat_id,
            message_id=call.message.message_id,
            reply_markup=None
        )
    except:
        pass
    
    offer_services(chat_id)

@bot.message_handler(func=lambda message: True)
def echo_message(message):
    if message.text.startswith('/') or message.text in ['‚ûï –ú–µ–º', 'üìÑ –ê–Ω–µ–∫–¥–æ—Ç']:
        return
    
    random_response = random.choice(RESPONSES)
    bot.reply_to(message, random_response)
    offer_services(message.chat.id)

if __name__ == '__main__':
    print('–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!')
    bot.infinity_polling()